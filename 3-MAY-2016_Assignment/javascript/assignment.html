<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>3-MAY-2016 Assignment</title>
    <meta name="description" content="page for providing solutions for daily challenge in javascript" />
    <meta name="author" content="vishnu" />
    <script>
// Divide and conquer
// If you looked for a word (“stentorian”, for example) in an actual book dictionary, would you turn to the first page, then the second page, then the third, examining all pages until you found the word? Of course not! You’d open to the center, finding the word “lightweight”. Undaunted by name-calling, and based on your alphabetical expertise, you look halfway to the books-end, where you find “ridicule”. Again you throw off this insult, looking even further toward the end of the book. The word you find is “terrible”, but like all Dojo students you don’t give up. Eventually you find your word “stentorian”, amidst stenographers and stepbrothers.
//
// This is an example of a technique known as “divide and conquer”. When you haven’t yet opened the dictionary, you don’t know much about which of the 3350 pages contains your word. After looking at page 1, all you really know is that the word is somewhere in the 2-3350 range – you haven’t narrowed it down much! If, instead of reading the first page, you glanced at a page in the middle (p.1675, let’s say), then with a single look you have cut the problem space in half. With a second glance at page 2513, you narrowed it even further and by looking at page 2900, you narrow the possibilities from 3350 pages down to “only” 400 pages: an 8x drop by checking only 3 pages. You can “divide and conquer” the problem space in this way, because words are listed in-order. Hold this thought for later….
//
// ============================================================================
// Here are today's challenges:
// Reverse array
// Given a numerical array, reverse the order of the values. The reversed array should have the same length, with existing elements moved to other indices so that the order of elements is reversed. Don’t use a second array – move the values around within the array that you are given.

// steps:
// 1. find length of the array
// 2. use a loop that iterates for exactly half the length (e.g., if len = 5, the iterator end condition will be < 2)
// 3. for every iteration swap a[i] with a[len-1-i]
// 4. print result
// can be done using the .reverse() built-in method
function revArr(arr){
  var lastIdx = arr.length - 1;
  var temp    = '';
  for (var i = 0; i < (arr.length / 2); i++){
    temp             = arr[lastIdx - i];
    arr[lastIdx - i] = arr[i];
    arr[i]           = temp;
  }
}

// myArray = [1,2,3,4,5,6,7,8,9,0];
// console.log(`The original array is ${myArray}`);
//
// revArr(myArray);
//
// console.log(`The reversed array is ${myArray}`);

// ============================================================================
// Remove negatives
// Implement removeNegatives() that accepts an array and removes any negative values.

// steps:
// 1. traverse array using loop
// 2. for each iteration, check the current value
// 3. if negative (< 0), remove element at that index and reduce iterator by 1
// 4. repeat step 3 till end of array
// the removal at specific index will be done using the splice() method
function remNeg(arr){
  for (var i = 0; i < arr.length; i++){
    if (arr[i] < 0){
      arr.splice(i,1);
      i--;
    }
  }
}

// myArray = [1,-2,-3,-4,5,-6,7,-8,9,-10];
// console.log(`The original array is ${myArray}`);
//
// remNeg(myArray);
//
// console.log(`The array with negatives removed is ${myArray}`);

// ============================================================================
// Array Min to Front
// Given an array of comparable values, move the lowest element to the array’s front, shifting backward elements that previously were ahead of it. Change [4,2,1,3,5] to [1,4,2,3,5].

// steps:
// 1. This is a bit similar to insertion sort but only for 1 element
// 2. first traverse the array to find the least element
// this can also be done using the "Math.min.apply(Math,array)" syntax but it has two disadvantages for our scenario:
  // - very confusing and at this point, is difficult to associate with finding the min value of array
  // - doesn't give us the index of the value. we will have to use the "indexOf()" method to find it
// 3. when found, save the index of the least element and the value
// 4. now start loop from beginning of array till the index identified
// 5. for each iteration, move all elements 1 spot to the right
// 6. assign the least element to the first index
function minToFront(arr){
  var min = arr[0];
  var minpos = 0;
  for (var i = 1; i < arr.length; i++){
    if (arr[i] < min){
      min = arr[i];
      minpos = i;
    }
  }

  for (var i = minpos; i > 0; i--){
    arr[i] = arr[i - 1];
  }

  arr[0] = min;
}

// myArray = [1,2,3,4,5,6,7,8,9,0];
// console.log (`The original array is ${myArray}`);
//
// minToFront(myArray);
//
// console.log(`The array after moving min to front is ${myArray}`);

// ============================================================================
// Skyline Heights
// From lovely Burbank you have a breathtaking view of the Los Angeles skyline. Let’s say you are given an array with heights of consecutive buildings, starting closest to you and extending directly away. Array [-1,7,3] would represent three buildings: first is actually out of view below street level, behind it is second at 7 stories high, third is 3 stories high (hidden behind the 7-story). You are situated at street level. Return array containing heights of buildings you can see, in order. Given [1,-1,7,3] return [1,7].

// steps:
// 1. since negative values are below street level, we can ignore them
// 2. start with the first positive value in the array. This is current.
// 3. Next find the next positive value in the array which is greater than current.
// 4. the newly identified value is now current.
// 5. repeat steps 3 and 4 till end of array
function heights(arr){
  var visible = [];
  var current;
  for (var i = 0; i < arr.length; i++){
    if (arr[i] > 0){
      if ((visible.length == 0) || (arr[i] >= current)){
        visible.push(arr[i]);
        current = arr[i];
      }
    }
  }
  return visible;
}
//
// buildings = [-1,2,-2,4,3,-3,6,5,8,9,7,-7];
// console.log(`The buiulding list is ${buildings}`);
//
// myView = heights(buildings);
//
// console.log(`My view is ${myView}`);

// ============================================================================
    </script>
  </head>
  <body>

  </body>
</html>
